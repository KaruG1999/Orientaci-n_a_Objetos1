# 📚 Síntesis OO1 - Semana 3
## Relaciones entre Objetos, Polimorfismo e Interfaces

---

## 🎯 **Conceptos Fundamentales**

### 1. **Relaciones entre Objetos**
> *"Los objetos no viven solos, se relacionan para colaborar"*

**Un objeto conoce a otro cuando:**
- ✅ **Lo mantiene como responsabilidad** (variable de instancia)
- ✅ **Le llega como parámetro** (relación temporal)
- ✅ **Lo crea** durante su ejecución
- ✅ **Lo obtiene** enviando mensajes a otros objetos

```java
public class CuentaBancaria {
    private Cliente titular;        // 🔗 Relación duradera: "siempre conozco mi titular"
    private double saldo;
    
    // 🔗 Relación temporal por parámetro
    public void transferir(double monto, CuentaBancaria destino) {
        this.debitar(monto);
        destino.acreditar(monto);    // "Le delego el trabajo de acreditar"
    }
    
    // 🔗 Relación temporal por creación
    public void debitar(double monto) {
        MovimientoBancario mov = new MovimientoBancario("DEBITO", monto);
        this.registrarMovimiento(mov);
    }
}
```

---

### 2. **`this` - El objeto hablando de sí mismo**
> *"Soy yo, hablando de mí mismo"*

**Usos principales:**
- **Descomponer métodos largos** en pasos más pequeños
- **Reutilizar comportamiento** entre métodos
- **Pasar mi referencia** para que otros me puedan contactar
- **Desambiguar** variables con el mismo nombre

```java
public class CuentaBancaria {
    private double saldo;
    
    public void transferir(double monto, CuentaBancaria destino) {
        if (this.puedeDebitar(monto)) {        // 🔄 "Me pregunto a mí mismo"
            this.debitar(monto);               // 🔄 "Me ordeno debitar"
            destino.acreditar(monto);
            this.notificarTransferencia();     // 🔄 "Me ordeno notificar"
        }
    }
    
    // Descomposición en métodos más simples
    private boolean puedeDebitar(double monto) {
        return this.saldo >= monto;
    }
}
```

---

### 3. **Identidad vs Igualdad**
> *"¿Son el mismo objeto o son equivalentes para mi negocio?"*

| Concepto | Operador/Método | Pregunta | Ejemplo |
|----------|----------------|----------|---------|
| **Identidad** | `==` | ¿Es el mismo objeto en memoria? | `juan1 == juan2` |
| **Igualdad** | `.equals()` | ¿Son equivalentes según mi dominio? | `juan1.equals(juan2)` |

```java
public class Persona {
    private String dni;
    private String nombre;
    
    // ⚖️ Igualdad: dos personas son iguales si tienen el mismo DNI
    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Persona) {
            Persona otra = (Persona) obj;
            return this.dni.equals(otra.dni);  // "¿Tenemos el mismo DNI?"
        }
        return false;
    }
}

// 🧪 Ejemplo práctico
Persona juan1 = new Persona("12345678", "Juan Pérez");
Persona juan2 = new Persona("12345678", "Juan Pérez");  // Nuevo objeto, mismo DNI

System.out.println(juan1 == juan2);      // ❌ FALSE - "¿Son el mismo objeto?"
System.out.println(juan1.equals(juan2)); // ✅ TRUE  - "¿Son iguales?" (mismo DNI)
```

---

### 4. **Interfaces - Contratos de Comportamiento**
> *"Una interfaz dice 'QUÉ' hacer, la clase dice 'CÓMO' hacerlo"*

**Beneficios:**
- ✅ **Desacopla** tipo de implementación
- ✅ **Permite polimorfismo** entre clases diferentes
- ✅ **Facilita extensibilidad** sin modificar código existente

```java
// 📋 Interfaz: define QUÉ se puede hacer
interface Destino {
    void escribir(String mensaje);  // "Prometo que sabes escribir"
}

// 📁 Implementación 1: escribir en archivo
class ArchivoLog implements Destino {
    private String rutaArchivo;
    
    @Override
    public void escribir(String mensaje) {
        // "YO escribo guardando en un archivo"
        try (FileWriter writer = new FileWriter(rutaArchivo, true)) {
            writer.write(mensaje + "\n");
        }
    }
}

// 🖥️ Implementación 2: escribir en consola
class ConsoleLog implements Destino {
    @Override
    public void escribir(String mensaje) {
        // "YO escribo mostrando en consola"
        System.out.println("[LOG] " + mensaje);
    }
}

// 🎯 Cliente: no le importa CÓMO, solo que sepa escribir
public class MonitorEventos {
    private Destino destino;  // "Solo sé que puede escribir"
    
    public void registrarEvento(String evento) {
        destino.escribir(evento);  // "No me importa cómo, solo que escriba"
    }
}
```

---

### 5. **Relaciones Uno-a-Muchos con Colecciones**
> *"No conozco a muchos, conozco a UNO que contiene muchos"*

```java
public class Empresa {
    private String nombre;
    private List<Empleado> empleados;      // 📦 "Conozco UNA lista"
    
    public Empresa(String nombre) {
        this.nombre = nombre;
        this.empleados = new ArrayList<>();  // "Creo mi colección vacía"
    }
    
    // ➕ Agregar: "Le digo a mi lista que agregue"
    public void contratar(Empleado empleado) {
        empleados.add(empleado);            // "Lista, agregá este empleado"
        empleado.setEmpresa(this);          // "Empleado, tu empresa soy yo"
    }
    
    // 🔍 Consultar: "Le pregunto a mi lista"
    public int cantidadEmpleados() {
        return empleados.size();            // "Lista, ¿cuántos tenés?"
    }
    
    // 🔄 Delegar a cada uno
    public double calcularTotalSueldos() {
        return empleados.stream()
                .mapToDouble(Empleado::getSueldo)    // "Cada empleado, dame tu sueldo"
                .sum();                              // "Sumo todos"
    }
}
```

---

### 6. **Delegación vs Envidia**

#### ❌ **Envidia (Mal diseño)**
> *"Soy envidioso: quiero hacer el trabajo de otros"*

```java
// ❌ CLASE ENVIDIOSA - MAL DISEÑO
public class OfertaEnvidiosa {
    private Producto producto;
    private double porcentajeDescuento;
    
    public double getPrecio() {
        // 🚫 ENVIDIA: "Le saco los datos y calculo yo"
        double precioBase = producto.getPrecioBase();
        double descuento = precioBase * (porcentajeDescuento / 100.0);
        return precioBase - descuento;
        
        // Problemas:
        // 1. Si cambia el cálculo, hay que modificar AQUÍ
        // 2. Esta clase conoce detalles internos del Producto
        // 3. El Producto es solo un "contenedor de datos"
    }
}
```

#### ✅ **Delegación (Buen diseño)**
> *"Cada uno hace lo que sabe hacer mejor"*

```java
public class Producto {
    private String nombre;
    private double precioBase;
    
    // ✅ DELEGACIÓN: "Yo sé calcular mi precio con descuento"
    public double getPrecioConDescuento(double porcentajeDescuento) {
        double descuento = precioBase * (porcentajeDescuento / 100.0);
        return precioBase - descuento;
    }
}

// ✅ CLASE QUE DELEGA - BUEN DISEÑO  
public class OfertaDelegadora {
    private Producto producto;
    private double porcentajeDescuento;
    
    public double getPrecio() {
        return producto.getPrecioConDescuento(porcentajeDescuento);
        // ✅ "Cada uno hace lo suyo"
    }
}
```

---

### 7. **Polimorfismo**
> *"Mismo mensaje, diferentes interpretaciones"*

**Características:**
- ✅ **Mismo mensaje** se envía a objetos de distintas clases
- ✅ **Diferentes implementaciones** del mismo comportamiento
- ✅ **No necesito saber** la clase específica del objeto

```java
// 🎨 Interfaz común
interface Figura {
    double area();      // "Prometo que sé calcular mi área"
    void dibujar();     // "Prometo que me sé dibujar"
}

class Circulo implements Figura {
    private double radio;
    
    @Override
    public double area() {
        return Math.PI * radio * radio;     // "YO calculo área como π×r²"
    }
    
    @Override
    public void dibujar() {
        System.out.println("Dibujando un círculo de radio " + radio);
    }
}

class Rectangulo implements Figura {
    private double ancho, alto;
    
    @Override
    public double area() {
        return ancho * alto;                // "YO calculo área como base×altura"
    }
    
    @Override
    public void dibujar() {
        System.out.println("Dibujando un rectángulo " + ancho + "x" + alto);
    }
}

// 🎭 POLIMORFISMO EN ACCIÓN
public class CalculadoraFiguras {
    // "Me da igual qué tipo de figura sea, todas saben calcular su área"
    public double calcularAreaTotal(List<Figura> figuras) {
        double total = 0;
        for (Figura figura : figuras) {
            total += figura.area();     // 🎭 POLIMORFISMO: cada una calcula diferente
        }
        return total;
    }
}
```

---

## 🛠️ **Ejercicios de la Semana - Aplicación Práctica**

### **Ejercicio 6: Distribuidora Eléctrica**
**Conceptos aplicados:**
- 🔗 **Relaciones entre objetos**: Usuario, Consumo, Factura, CuadroTarifario
- 📊 **Modelado de dominio** con UML
- 🎯 **Identificación de responsabilidades**

### **Ejercicio 7: Figuras y Cuerpos**
**Conceptos aplicados:**
- 🎭 **Polimorfismo**: Círculo y Cuadrado con comportamientos similares
- 🔄 **Delegación**: Cuerpo3D delega cálculos a figuras 2D
- 📋 **Interfaces implícitas** para contratos comunes

### **Ejercicio 8: Genealogía Salvaje**
**Conceptos aplicados:**
- 🌳 **Relaciones recursivas**: mamífero conoce a padre y madre
- 🔄 **Delegación recursiva**: para encontrar ancestros
- 📦 **Manejo de colecciones** para relaciones complejas

### **Ejercicio 9: Red de Alumbrado**
**Conceptos aplicados:**
- 🔗 **Relaciones bidireccionales**: farola conoce a sus vecinas
- 🌊 **Patrón de propagación**: encendido se propaga en cadena
- 🎯 **Coordinación entre objetos**

---

## ⭐ **Conceptos Clave para Recordar**

### 🧠 **Frases Memorables**

1. **Relaciones**: *"Los objetos colaboran, no viven aislados"*
2. **this**: *"Soy yo hablando de mí mismo"*
3. **Identidad vs Igualdad**: *"== pregunta '¿es el mismo?', equals() pregunta '¿son equivalentes?'"*
4. **Interfaces**: *"Interfaz dice QUÉ, clase dice CÓMO"*
5. **Colecciones**: *"No conozco a muchos, conozco a UNO que contiene muchos"*
6. **Delegación**: *"Cada uno hace lo que sabe hacer mejor"*
7. **Polimorfismo**: *"Mismo mensaje, diferentes interpretaciones"*

### 💡 **Consejos Prácticos**

- ✅ **Usa `this` siempre** en OO1, aunque sea opcional
- ✅ **Implementa `equals()`** pensando en tu dominio de negocio
- ✅ **Prefiere interfaces** a clases concretas para tipear variables
- ✅ **Delega responsabilidades** en lugar de ser envidioso
- ✅ **Busca polimorfismo** cuando veas muchos `instanceof` o `if-else`

### 🚨 **Señales de Mal Diseño**

- ❌ **Envidia**: Una clase accede a muchos datos de otra
- ❌ **Código rígido**: Muchos `instanceof` en lugar de polimorfismo  
- ❌ **Responsabilidades confusas**: No está claro quién debe hacer qué
- ❌ **Alto acoplamiento**: Cambiar una clase obliga a cambiar muchas otras

---

## 🎯 **Mensaje Final**
> *"El diseño orientado a objetos exitoso se basa en la colaboración: objetos que se conocen, se comunican, delegan responsabilidades y trabajan juntos polimórficamente para resolver problemas complejos de manera elegante y mantenible."*